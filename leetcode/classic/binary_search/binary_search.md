二分搜索中最常见的bug就是死循环，或者总是跳过预期数字，因此我们需要对二分搜索进行一个细致的分析  

首先，代码中的left和right初始值为0，len(nums)-1  
1. 因此想用二分搜索的第一件事是明确场景是否存在len(nums) == 0的case，如果存在需要明确处理
2. 承接第一点，此时数组长度至少为1，接下来就是不断的二分查找直到搜索终止，那么终止条件是什么呢？
3. 首先，mid怎么计算？
   1. 如果是`(left+right)/2`，如果数组长度为奇数，那索引是正中间的元素；但是如果数组长度为偶数，那么mid元素会向左倾斜，即靠近left
   2. 同理如果是`(left+righ+1)/2`，如果数组长度为奇数，那索引是正中间的元素，但是如果数组长度为偶数，则mid元素会向右倾斜，靠近right
   3. 因此我们在迭代过程中，一定要关注left和right移动的情况，匹配mid的计算，如果我们采用1中向左偏移的条件，如果我们要修改left，一定不能`left = mid`，因为当`left = right -1`时, `mid=left`，然后我们`left=mid`会出现死循环；同理，我们用2中向右偏移的条件，我们不能以`right=mid`的方式修改right
   4. 当我们避免了上述的问题，则根据`left < right`(保证二分查找的范围存在至少两个元素) or `left <= right`(保证二分查找的范围存在至少一个元素) 作为循环条件执行
