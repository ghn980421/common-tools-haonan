# Kadane 算法
Kadane算法算是动态规划的一个分支，主要用于求解子数组求和问题  
对于某一个数组，最容易想到的方法当然是遍历所有的子数组可能性，从而得出最大或者最小的子数组和，时间复杂度为O(N^2)  
但是这个方法随着数组长度的增长，效率衰退的很厉害，因此是否能想到线性复杂度的方法来求解该类问题？  

线性复杂度代表程序是有常数次的数组遍历解决问题  
假设数组遍历到索引0，那么以索引0结束的子数组只有`[nums[0]]`  
继续遍历，遍历到索引1，那么以索引1结束的子数组有`[nums[1]]`, `[nums[0], nums[1]]`
继续遍历，遍历到索引2，那么以索引2结束的子数组有`[nums[0], nums[1], nums[2]]`,`[nums[1], nums[2]]`,`[nums[2]]`  

每次新增的子数组枚举为`[nums[i]]`, 那么新的问题产生了，哪个是最大或者最小的子数组？  
当结束索引为i-1时，以i为结尾的子数组有i个，从i-1到i，本质上是给所有枚举的子数组加入元素`nums[i]`，本质上最大值即是`max(sumArray(i-1), 0) + nums[i]`  

每轮遍历得到以i为结束的最大子数组和，用于计算下一个以i+1为结束索引的子问题，本质上即为动态规划，但kadane算法只保存一个局部最值，而非一个动态数组