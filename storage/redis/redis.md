# Redis 常用知识点:
## Redis的数据结构：
redis总共有五种常用数据类型，key对象都是string，value对象可能是string、list、hashmap、set以及sorted set;  
根据数据size的不同，底层实现的方式可能有所不同

### 字符串对象:
日常项目中，最常用的对象无非就是字符串对象，用来作为某些对象的缓存或者某些简单的计算  
字符串的底层实现分为三种：
1. int类型，当存储内容为整型或者long类型的整数时，由于整数占用空间小，因此直接存储在对象内，不需要额外空间；同时方便频繁的数字计算
2. embstr类型，当存储的字符串的长度小于某个阈值(不同版本不一样咯)，即该redis对象为一块连续完整的内存，对象基本信息之后紧跟一个sds对象
3. raw类型，redis对象里存有一个指向sds内存块的指针

#### int类型：
当存储对象是整型或long类型的整数时，一般会按照int编码的方式进行存储，整型一般为1～4个字节，占用空间小，无需额外存储分配，直接存入对象即可；  
同时，执行INCR等命令时，无需转换为字符串，直接进行整型计算，减少了类型转换的开销；

##### 当存储对象为浮点数或者字符串的时候，底层会用紧凑型字符串(embstr)或者原生的字节数组(raw)，由对象大小决定
#### embstr类型：
set一个字符串键时，根据字符串的长度决定编码类型，当字符串对象较小时，redis会为该对象分配一块连续的内存(对象类型，编码类型以及存储内容的sds)
#### raw类型：
当embstr对象超过了阈值或对象初始大小较大时，redis会为该对象分配两块内存，一块是存有字符串内容的sds，另一块则是redis对象并指向对应的sds

##### embstr相比于raw，内存分配和内存释放的次数各少了一次，减少内存操作意味着减少系统调用从而提升命令执行的效率；同时减少因额外分配空间释放导致的内存碎片
##### 同时连续的内存空间，无用额外寻址；因此可以方便利用缓存的特性，进一步优化查询性能(当然我觉得这块差别很微小)

### 列表对象：
列表对象指对应的键存有一系列对象，底层是由ziplist或者linkedlist实现
#### ziplist:
当列表内元素大小较小并且总的元素个数比较少的时候，列表对象会分配一块连续的内存存储列表对象及其元素对象们  
ziplist可看作编程语言中的数组，对象之间的内存连续
```
type ziplist struct {
    zlbytes int // 该字段用来存储ziplist总共占据内存多少字节空间
    zltail int //  尾指针，主要代表该ziplist内存起始地址到尾节点之间的偏移字节
    zllen int // 长度，即元素个数
    content []zipnode 指向具体元素存储的内存，是一个compacted array
    zlend int // 结束字节
}

type zipnode struct {
    previous_entry_size 1个字节或者5个字节 // 用来描述该节点的前一节点的内存大小，使得尾节点可以向前索引  
    encoding_type // 长度为1，2或者5字节，当该字段仅一个字段时，该entry内存的元素是整型元素；若为2或5字节，则该entry内存的事字节数组，同时包含数组的长度
    content // 具体内容
}
```
从上面ziplist的结构可以看出，每个node是一个可能变化的结构，比如LPUSH、LPOP，从列表头插入或者删除一个元素，那么每个节点的previous_entry_size可能都会发生变化，那么相应节点的内存以及后续节点的位置都需要移动，
极端情况下，每个元素的previous_entry_size都发生变化，整体的时间复杂度会退化到O(N^2)

#### linkedlist:
当元素大小较大或者元素个数较多时，ziplist会升级为双向链表，链表中每个对象都是一个string对象，如上所述

### 哈希对象：
哈希对象底层实现是ziplist或者dict字典，压缩列表的结构上面已经介绍过了，只不过哈希对象会按照键值对一个键和一个值交替存入压缩列表
#### dict实现：
当元素比较多且元素大小比较大时，redis会使用字典对哈希对象进行编码实现，采用seperate chaining的方式，字典内持有两个hashmap，一般情况下只使用第一个，
当正在进行rehash时，另一个hashmap才会使用  
seperate chaining 这个rehash的策略很熟悉了，就不再赘述了；而渐进式的rehash过程跟之前在golang内学习map的方式几乎一样，所以也不再多花时间了

### 集合对象：
普通的集合对象根据元素类型和元素数目决定底层实现是intset(整数集合)or hashmap
#### intset：
若该集合内的元素都为整数且元素数目较少时，会使用整型集合作为底层实现
```
type intset struct {
    encoding uint32 // 整型元素的编码方式，决定底层数组的元素类型是int16, int32还是int64
    length uint32 // 当前集合数组的长度
    content []intxx // 集合数组，元素类型取决于encoding的方式，元素唯一且有序(为了唯一性判断方便，二分)    
}
```

如果元素类型为其他或者元素数目比较多时，底层会采用hashmap进行实现，只不过value存的是null对象

### 有序集合对象：
底层实现是ziplist或者skiplist，如果是ziplist，content则会存集合的元素及其分数值
如果是skiplist的实现方式，zset内会包含一个字典以及跳表
```
type zset struct {
    skiplist // 用logN的复杂度索引到指定的集合元素
    dict // 字典主要是为根据分数快速索引到集合对象
}
```
如果不用跳表实现，而是用普通的列表+实时的排序，那么每次查询的时间复杂度都是O(NlogN)外加O(logN)的栈空间  
那么跳表为什么查询性能这么好呢，本质上是在原始链表上建立多级索引，假设链表的长度为N，每两个节点之间抽一个索引，则一级索引的个数为N/2,二级索引为N/4，直到第k级索引为1  
那么总共多出来的索引节点个数为N/2 + N/4 + ...... + 1 = 2^k - 1，k为元素个数即logN, 即结果为N-1，其实就是用额外的空间，将查询的时间复杂度优化为了O(logN)  
当然，设计数据结构时，我们也可以每三个节点抽一层索引，减少内存的消耗，不过相应查询效率会有所损耗，根据应用场景调整

跳表索引的建立和更新：  
那么我们如果在插入元素的同时，去判断是否需要添加索引，需要给那几层添加索引呢？  
一般的方法(包括redis中zset的实现)，均为如下方法：  
按理说，第一层索引我们希望有N/2个元素作为索引，即每个元素作为第一层索引的概率为1/2；第二层索引我们希望有N/4个索引，即每个元素作为第二层索引的概率为1/4，以此类推  
这种方法最坏的插入情况，就是该元素每层都需要安排一个索引，现在对应层寻找该元素要插入的节点，然后插入，时间复杂度为O(logN1+logN2 + ......+logN)，即O(logN)；
同理删除元素时，删除索引复杂度也是一样

