# mysql重要知识点：

## 基础知识：
### 数据库三范式：
1. 第一范式：数据库的每一列具备原子性，不可分割
2. 第二范式：属性完全依赖于主键，不能存在仅依赖主键一部分的属性
3. 第三范式，确保每一列都与主键直接相关，属性不依赖于其他非主键的属性

关于第一范式，不符合这个范式的例子是某个字段是一堆数字的集合或者是大json，那么数据的部分更新需要极高的人力成本维护  
因此在设计数据库列的时候尽量原子简单，可以存储json之类的非原子内容，如果只是存储和读取，不需要更新

第二范式和第三范式本质上很相似，即一张表内的属性不能只和主键的一部分有关，更不能完全不和主键相关，去依赖于其他非主属性  
每一个属性都是和每一个主键直接关联，这两个范式是在表设计过程中，某些字段和内容可以单独拆分成一张单独的表，而不是集合在一张大宽表内  

比如一个记录订单内sku价格的表，那么联合主键是订单id+skuid，对应的字段是下单价，如果此时你把sku描述放到这个表内，因为这个字段只跟sku相关，那么这个字段在该表就会冗余很多，因为多笔订单可能下同一笔sku

### mysql 执行sql语句的过程
1. client同mysql server 通过tcp建连
2. sql语句通过网络传送到server，sql的语法分析器分析sql的合理性，对应的表字段、结构是否正确
3. 然后，sql优化器生成最优的执行计划(比如使用哪个索引)
4. 执行引擎到存储引擎对数据进行操作

### MySQL建表的约束条件有哪些？
1. 主键约束：自增主键或者联合主键指向数据库内一条唯一的记录
2. 唯一约束：除了主键之外，根据应用的概念，多个字段组合成唯一索引，在表内指向唯一的记录
3. 检查约束：对该列数据的范围、格式的限制，比如类型的字节长度
4. 默认约束：该数据的默认值
5. 外键约束：主表某个字段作为其他表的主键

### 索引
#### 经典问题，为什么索引选择用B+树，而不是B树，BST树，AVL树，红黑树？
1. 为什么不是平衡树？
   1. 首先平衡树是二叉的，随着数据记录的增多，二叉平衡树的高度相比于b树或者b+树这类多分叉树膨胀的会很快，导致内存加载索引文件的I/O消耗会比较大
   2. 平衡树具有严格意义的平衡维护规则，可能插入或者删除一个节点，就需要对树的结构进行调整(这点我不觉得是主要原因)
2. 为什么不是二叉平衡树？
   1. 第一个原因是因为二叉结构导致的树高度膨胀，带来的I/O消耗
   2. 第二个原因则是二叉搜索树在某些情况下，会退化成链表，只是查询索引的复杂度会退化到O(N)
3. 为什么不是B树？而是B+树？
   1. 首先二者的区别对选择很重要，B树是每个节点会存储索引值+数据记录(非聚簇索引则会存储主键)，而B+树则是非叶子节点只存储索引值，叶子节点存储索引+数据记录，叶子节点之间通过数据页+链表的形式维护有序性
   2. 如果是索引某个或者某几个记录，那执行效率是一样的都是对数级别的遍历；但是如果是范围查找比如a>1这种，b树就支持的很差，需要递归遍历所有符合条件的子树；而b+树只需要查找到边界，然后遍历叶子节点的内存页即可，顺序I/O

#### 名词概念：
##### 主键索引和非主键索引：
主键索引：B+树的叶子节点存的是整行数据，在InnoDB内，也被称为聚簇索引
非主键索引：B+树的叶子节点内存的事主键，在InnoDB内，也被称为二级索引或者非聚簇索引；
##### 回表和覆盖索引：
通过二级索引索引到指定的主键，再用主键索引回表拉去数据记录的过程被称为回表  
eg. `SELECT * FROM t WHERE k = 5` 先索引到k=5的主键集合，然后在用主键查询对应的数据

覆盖索引：当`select a, b from table where k > 3 and k< 5`，假设a和b是table的联合主键，那么通过索引k可直接拉去到主键信息，无需回表，减少树的搜索次数

##### 前缀索引
在对字符串创建索引, 如INDEX(name)中, 若字符串非常大, 那么响应的空间使用和维护开销也非常大, 就可以使用字符串从左开始的部分字符创建索引, 减少空间和维护的成本, 但是也会降低索引的选择性

索引的选择性指的是: 不重复的索引值和数据表的记录总数(T)的比值, 范围为1/T ~ 1之间, 索引选择性越高则查询效率越高. 对于BLOB, TEXT, VARCHAR等类型的列, 必须使用前缀索引, MySQL不允许索引这些列的完整长度.

先计算完整列的选择性`SELECT COUNT(DISTINCT name)/COUNT(1) FROM t`
在计算不同前缀长度N的选择性`SELECT COUNT(DISCTINCT LEFT(name, N)) / COUNT(1) FROM t`
看哪个N更靠近1, 进行索引的创建

#### 索引何时失效？
1. 使用 != 或  <>
2. 类型不一致导致索引失效
3. 函数导致的索引失效, 函数用在索引列时, 不走索引,如 `SELECT * FROM t WHERE DATE(create_time) = 'yyyy-MM-dd'`
4. 运算符导致的索引失效 如 `SELECT * FROM t WHERE k - 1 = 2`, 若有INDEX(k), 则不走索引
5. OR引起的索引失效 如 `SELECT * FROM t WHERE k = 1 OR j = 2`, 若有INDEX(k), 则不走索引, 如果OR连接的时同一个字段, 则不会失效
6. 模糊查询导致的索引失效 如 `SELECT * FROM t WHERE name = '%三'`, %放字符串字段前匹配不走索引
7. NOT IN, NOT EXISTS导致索引失效


### 事务
