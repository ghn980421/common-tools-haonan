# mysql重要知识点：

## 基础知识：
### 数据库三范式：
1. 第一范式：数据库的每一列具备原子性，不可分割
2. 第二范式：属性完全依赖于主键，不能存在仅依赖主键一部分的属性
3. 第三范式，确保每一列都与主键直接相关，属性不依赖于其他非主键的属性

关于第一范式，不符合这个范式的例子是某个字段是一堆数字的集合或者是大json，那么数据的部分更新需要极高的人力成本维护  
因此在设计数据库列的时候尽量原子简单，可以存储json之类的非原子内容，如果只是存储和读取，不需要更新

第二范式和第三范式本质上很相似，即一张表内的属性不能只和主键的一部分有关，更不能完全不和主键相关，去依赖于其他非主属性  
每一个属性都是和每一个主键直接关联，这两个范式是在表设计过程中，某些字段和内容可以单独拆分成一张单独的表，而不是集合在一张大宽表内  

比如一个记录订单内sku价格的表，那么联合主键是订单id+skuid，对应的字段是下单价，如果此时你把sku描述放到这个表内，因为这个字段只跟sku相关，那么这个字段在该表就会冗余很多，因为多笔订单可能下同一笔sku

### mysql 执行sql语句的过程
1. client同mysql server 通过tcp建连
2. sql语句通过网络传送到server，sql的语法分析器分析sql的合理性，对应的表字段、结构是否正确
3. 然后，sql优化器生成最优的执行计划(比如使用哪个索引)
4. 执行引擎到存储引擎对数据进行操作

### MySQL建表的约束条件有哪些？
1. 主键约束：自增主键或者联合主键指向数据库内一条唯一的记录
2. 唯一约束：除了主键之外，根据应用的概念，多个字段组合成唯一索引，在表内指向唯一的记录
3. 检查约束：对该列数据的范围、格式的限制，比如类型的字节长度
4. 默认约束：该数据的默认值
5. 外键约束：主表某个字段作为其他表的主键

## 索引
### 经典问题，为什么索引选择用B+树，而不是B树，BST树，AVL树，红黑树？
1. 为什么不是平衡树？
   1. 首先平衡树是二叉的，随着数据记录的增多，二叉平衡树的高度相比于b树或者b+树这类多分叉树膨胀的会很快，导致内存加载索引文件的I/O消耗会比较大
   2. 平衡树具有严格意义的平衡维护规则，可能插入或者删除一个节点，就需要对树的结构进行调整(这点我不觉得是主要原因)
2. 为什么不是二叉平衡树？
   1. 第一个原因是因为二叉结构导致的树高度膨胀，带来的I/O消耗
   2. 第二个原因则是二叉搜索树在某些情况下，会退化成链表，只是查询索引的复杂度会退化到O(N)
3. 为什么不是B树？而是B+树？
   1. 首先二者的区别对选择很重要，B树是每个节点会存储索引值+数据记录(非聚簇索引则会存储主键)，而B+树则是非叶子节点只存储索引值，叶子节点存储索引+数据记录，叶子节点之间通过数据页+链表的形式维护有序性
   2. 如果是索引某个或者某几个记录，那执行效率是一样的都是对数级别的遍历；但是如果是范围查找比如a>1这种，b树就支持的很差，需要递归遍历所有符合条件的子树；而b+树只需要查找到边界，然后遍历叶子节点的内存页即可，顺序I/O
   3. B树每个节点都包含主键或者数据记录，一个节点的数值大于一个B+树节点，那么按照操作系统一次读取指定大小的内存页，B+树所容纳的节点个数更多，相对来说I/O次数更小

### 名词概念：
#### 主键索引和非主键索引：
主键索引：B+树的叶子节点存的是整行数据，在InnoDB内，也被称为聚簇索引
非主键索引：B+树的叶子节点内存的事主键，在InnoDB内，也被称为二级索引或者非聚簇索引；
#### 回表和覆盖索引：
通过二级索引索引到指定的主键，再用主键索引回表拉去数据记录的过程被称为回表  
eg. `SELECT * FROM t WHERE k = 5` 先索引到k=5的主键集合，然后在用主键查询对应的数据

覆盖索引：当`select a, b from table where k > 3 and k< 5`，假设a和b是table的联合主键，那么通过索引k可直接拉去到主键信息，无需回表，回表意味着根据指定的主键进行随机I/O，效率随着数据量的增大相对较差

#### 前缀索引
在对字符串创建索引, 如INDEX(name)中, 若字符串非常大, 那么响应的空间使用和维护开销也非常大, 就可以使用字符串从左开始的部分字符创建索引, 减少空间和维护的成本, 但是也会降低索引的选择性

索引的选择性指的是: 不重复的索引值和数据表的记录总数(T)的比值, 范围为1/T ~ 1之间, 索引选择性越高则查询效率越高. 对于BLOB, TEXT, VARCHAR等类型的列, 必须使用前缀索引, MySQL不允许索引这些列的完整长度.

先计算完整列的选择性`SELECT COUNT(DISTINCT name)/COUNT(1) FROM t`
在计算不同前缀长度N的选择性`SELECT COUNT(DISCTINCT LEFT(name, N)) / COUNT(1) FROM t`
看哪个N更靠近1, 进行索引的创建

#### 索引何时失效？
1. 使用 != 或  <>
2. 类型不一致导致索引失效
3. 函数导致的索引失效, 函数用在索引列时, 不走索引,如 `SELECT * FROM t WHERE DATE(create_time) = 'yyyy-MM-dd'`
4. 运算符导致的索引失效 如 `SELECT * FROM t WHERE k - 1 = 2`, 若有INDEX(k), 则不走索引
5. OR引起的索引失效 如 `SELECT * FROM t WHERE k = 1 OR j = 2`, 若有INDEX(k), 则不走索引, 如果OR连接的时同一个字段, 则不会失效
6. 模糊查询导致的索引失效 如 `SELECT * FROM t WHERE name = '%三'`, %放字符串字段前匹配不走索引
7. NOT IN, NOT EXISTS导致索引失效


## 事务
### 事务的四大特性：
1. 原子性：即事务内所有的命令是一个不可拆分的工作单位，要么全部提交，要么部分提交
2. 一致性：根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。这种状态是语义上的而不是语法上的，跟具体的业务有关
3. 隔离性：事务之间的执行是隔离的，不能互相干扰
4. 持久性：试图一旦提交，数据库内的数据即永久改变，即使出现了故障，但也能恢复

#### 原子性的实现：
mysql具有undo log, 事务开始时，server会为事务生成一个undo log文件；每执行事务中的一条写命令，undo log都会产生一条撤销该操作的回滚sql；
当事务执行失败或者手动调用rollback，mysql利用undo log的内容进行回滚；如果事务成功提交，则该log文件会被刷入磁盘

#### 一致性的实现：
首先一致性是事务最终实现的目标，即执行事务后的数据要符合程序设计，比如优惠金额的字段不能经过算价变成负的，从数据库字段约束的角度，负值没毛病；但是字段语义上是不合理；  
因此应用层要判断修改后数据的合法性和一致性

#### 隔离性的实现：
隔离性主要是通过锁+mvcc实现不同的隔离级别

再具体描述隔离性的实现之前，我们先简单了解下mysql的锁以及mvcc的原理

##### 锁：
mysql的锁实现，大致分为最基本的两类，一个是共享锁，一个是排他锁，只有共享锁是可重入的，排他锁和二者都是互斥的

当事务内执行命令时，比如`update table set balance = 50 where user_id = 123`, 如果user_id是普通索引或者是联合索引的最左列，那么根据索引树，事务会获取user_id = 123所有记录的排他锁；这样其他事务因为获取不到该记录的锁，从而被阻塞直到持有锁的事务结束  
当然，如果执行语句的查询条件是没有索引或者不符合最左匹配，那么行锁会升级到表锁，将这个表锁住，任何对表的读写都会被阻塞

mvcc原理是，每个事务都只能读取到小于当前事务编号的最新数据快照，更准确的说，事务开始的时候，mvcc会维护一个数据表的快照，无论其他事务怎么修改，该事务一切读取操作都是依赖该快照的

我们知道mysql底层是如何进行同步的，那么按照隔离级别从低到高来描述事务隔离性的具体实现
1. 未提交读：
   1. 只保证数据不会并发更新，即用排他锁锁定更新记录行且排他锁无需等待事务结束即可释放，因为对于其他事务未提交的修改，事务依旧可以给这些记录添加共享锁，从而读到未提交的修改；
   2. 这种隔离级别最大的问题就是会造成数据的不一致，当读取到其他事务的改动因某种原因回滚，那么对于读取事务就出现了读取到的数据和实际数据的不一致，最终导致事务的执行不能匹配一致性，这种现象成为脏读
2. 已提交读：
   1. 为了解决未提交读的脏读问题，mysql要求更新数据的排他锁必须在事务结束之后才能释放，保证未提交的改动不能被其他事务读取，因此当事务读取到其他事务正在修改的记录时，会因为排他锁而阻塞直到修改事务结束
   2. 换句话说，当修改被提交之后，其他事务就可以读取到变动了；意味着某个事务内同一条sql读取到的数据可能内容会不一样，即不可重复读的问题；不可重复读本质上是，事务不同时刻读取的数据记录不一样，因此依赖于不同时刻读的数据，会导致不同的程序执行动作，造成不一致性
3. 可重复读：
   1. 进一步，为了使得事务不同时刻读取的数据不受到其他事务提交的影响，因此事务开始时，事务会获取当前的数据快照，事务的执行都是依赖这份快照；其他事务的已提交变动不影响该事务
   2. 那么，对于事务来说，读取到的数据保证了前后的一致，但可能是旧数据，则数据没有按照预期顺序执行最终导致不一致性，所以需要应用层自己处理，比如事务外先抢锁，抢到锁需要判断当前数据是否符合预期，然后修改
4. 可串行化：
   1. 这个不多说了，所有事务按照要求同步串行执行

此外有种问题，没有在上述的隔离实现中描述，被称为幻读，一般会出现在已提交读中

从上述锁的实现中，我们发现锁是某个线程获取到对某些数据的执行权，但是当我们插入某条数据时，mysql是没有什么限制的，那么除了某条数据发生变化的不可重复读；数据的数量也发生变化，即事务的修改好像没有执行完成

因此，在可重复读的实现中，通过数据快照的方式解决了幻读问题；那么在更低的隔离级别，比如已提交读内，怎么解决幻读问题？

比如，公司要给所有50岁以上的员工发礼物，此时后台程序操作并完成`update table set gift = coupon where age > 50`，在事务提交之前，另一个线程添加了新入职的员工a，大于50岁，那么按照行锁的方式，这个新添加员工是没有被update的

因此需要有间隔锁，`select * from table where age > 50  for update` 即事务执行过程中不能插入大于50的元素，插入操作会因为间隙锁而阻塞直到锁释放
##### 持久化的实现:
持久化主要是依托redo log记录每一个事务的执行结果，并将日志存入磁盘，只要事务提交，redo log就会落盘，那么server宕机也可以随时恢复丢失的数据

为了保证数据的持久化，mysql一般采用WAL(write-ahead log)的写入策略，即执行数据的更新之前，先进行日志的写入，将redo log写入buffer，之后将更新的数据从磁盘加载到内存进行更新，事务提交，redo log刷盘  
数据并不会随着redo log一起刷盘，而是定时+文件缓冲区满时，一次刷盘，减少I/O次数，redo log因为是append顺序I/O(相邻内存块减少寻址时间，同时数据块也会预先加载减少等待)，所以性能损耗较小；而数据持久化则是随机I/O效率较低，因此尽量减少次数

## 主从架构
主节点一般是用redo log进行数据的恢复，而从节点则是用binlog进行数据的写入和恢复的

binlog的内容一般分为两种:
1. statement，记录的为sql语句，即描述一个sql语句造成的影响
2. row，记录的是每一行的改动，修改前和修改后的变动

binlog在主从架构下，除了保证从节点的写入和数据复制，还用来配合redo log判断主节点数据是否需要回滚  

当一个事务执行时，redo log和undo log都是随着执行过程不断往buffer内写入，加入binlog是在提交事务时写入的，那么事务提交成功，但是binlog没有写入，则从库相比于主库会少了本次操作

因此，InnoDB采用两阶段的事务提交方式，拆分为prepare和commit：
1. 执行事务过程中，写入redo log和undo log，此时事务处于prepare状态
2. 修改内存数据，写入binlog
3. 事务处于commit状态，提交事务，redo log和undo log落盘

那么当server宕机时，这三个log可分为redo log和binlog，有以下几种情况:
1. 当redo log文件包含该事务时，binlog一定也写入了，因为binlog写入是在事务提交+redo log落盘之前写入的，此时该事务需要恢复数据；即redo log落盘一定表明该事务执行完成  
2. 当redo log无事务信息或者事务信息不全(并非同步刷盘)，但是binlog有，则表明数据已经写入但是提交时有问题，那么该数据mysql认为操作是合理的，则根据binlog进行逻辑恢复，同时补全redo log
3. 当redo log无事务信息或者事务不全，但是无对应事务的binlog，则需要回滚这部分redo log

