# 操作系统常用概念与问题(不定时更新)：
## 操作系统的内存管理：
### 物理内存与虚拟内存：
#### 物理内存：
实际的存储地址空间，缓存+寄存器+内存+磁盘这些存储组件组成的空间；  
但随着多任务开发以及云容器技术的流行，物理内存的管理和程序开发的耦合给工程师带来了极大的复杂度：  
1. 工程师需要在代码里对代码进行谨慎地操作，避免多进程、多线程对同一内存对象进行不符合预期地修改；  
2. 必须恰当地向os申请合适的内存对象，申请多了，容易有内存浪费+内存碎片；申请少了，又需要频繁的向os申请
3. 程序使用完成，必须在合适的时候释放不使用的内存，否则会引起内存泄漏  

因此，引入了虚拟内存的概念，使得各进程从自身角度仿佛拥有了整个物理内存
#### 虚拟内存
假设一个内存空间是0x0000～0xFFFF，即2B，那么每个进程的地址空间都是0X0000～0XFFFF，但实际上进程所分配的物理内存只是很小一部分；  
cpu执行进程指令时候，比如`mov $s1 0x0001`，需要从指定的内存地址处加载数据到寄存器，cpu内部的MMU(内存管理单元)会进行加载，具体过程如下:  
MMU内部由三部分组成: TLB(buffer)+PTE(页表条目)+Disk(磁盘)，类似于本地缓存+分布式缓存+持久化存储  
1. MMU会先访问TLB，如果有对应虚拟地址和物理地址的转换映射的话，直接使用；没有的话则去查询页表条目
2. PTE(页表条目)存储在内存的固定位置，如果有的则直接使用；无的话，只能去指定的磁盘空间去置换索引了

更细致一点，通常程序的逻辑地址是有段选择子(segment selector)以及偏移量(offset)组成的，这些地址在编译之后就已经确定好了  
根据段选择子索引获取对应的段描述符信息(访问权限，base地址等)，加上offset，即可在进程的逻辑空间内索引到具体的逻辑地址，然后根据上述的MMU转换为物理地址
